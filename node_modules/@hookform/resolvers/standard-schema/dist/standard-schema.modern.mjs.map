{"version":3,"file":"standard-schema.modern.mjs","sources":["../src/standard-schema.ts"],"sourcesContent":["import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport { StandardSchemaV1 } from '@standard-schema/spec';\nimport { FieldError, FieldValues, Resolver } from 'react-hook-form';\n\nfunction parseIssues(\n  issues: readonly StandardSchemaV1.Issue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n\n  for (let i = 0; i < issues.length; i++) {\n    const error = issues[i];\n    const path = error.path?.join('.');\n\n    if (path) {\n      if (!errors[path]) {\n        errors[path] = { message: error.message, type: '' };\n      }\n\n      if (validateAllFieldCriteria) {\n        const types = errors[path].types || {};\n\n        errors[path].types = {\n          ...types,\n          [Object.keys(types).length]: error.message,\n        };\n      }\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Creates a resolver for react-hook-form that validates data using a Standard Schema.\n *\n * @param {Schema} schema - The Standard Schema to validate against\n * @param {Object} resolverOptions - Options for the resolver\n * @param {boolean} [resolverOptions.raw=false] - Whether to return raw input values instead of parsed values\n * @returns {Resolver} A resolver function compatible with react-hook-form\n *\n * @example\n * ```ts\n * const schema = z.object({\n *   name: z.string().min(2),\n *   age: z.number().min(18)\n * });\n *\n * useForm({\n *   resolver: standardSchemaResolver(schema)\n * });\n * ```\n */\nexport function standardSchemaResolver<\n  TFieldValues extends FieldValues,\n  Schema extends StandardSchemaV1<TFieldValues, any>,\n>(\n  schema: Schema,\n  resolverOptions: {\n    raw?: boolean;\n  } = {},\n): Resolver<NonNullable<(typeof schema)['~standard']['types']>['output']> {\n  return async (values: TFieldValues, _, options) => {\n    let result = schema['~standard'].validate(values);\n    if (result instanceof Promise) {\n      result = await result;\n    }\n\n    if (result.issues) {\n      const errors = parseIssues(\n        result.issues,\n        !options.shouldUseNativeValidation && options.criteriaMode === 'all',\n      );\n\n      return {\n        values: {},\n        errors: toNestErrors(errors, options),\n      };\n    }\n\n    options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n    return {\n      values: resolverOptions.raw ? Object.assign({}, values) : result.value,\n      errors: {},\n    };\n  };\n}\n"],"names":["standardSchemaResolver","schema","resolverOptions","values","_","options","result","validate","Promise","issues","errors","validateAllFieldCriteria","i","length","_error$path","error","path","join","message","type","types","_extends","Object","keys","parseIssues","shouldUseNativeValidation","criteriaMode","toNestErrors","validateFieldsNatively","raw","assign","value"],"mappings":"uSAqDgB,SAAAA,EAIdC,EACAC,EAEI,CAAA,GAEJ,OAAcC,MAAAA,EAAsBC,EAAGC,KACrC,IAAIC,EAASL,EAAO,aAAaM,SAASJ,GAK1C,GAJIG,aAAkBE,UACpBF,QAAeA,GAGbA,EAAOG,OAAQ,CACjB,MAAMC,EAjEZ,SACED,EACAE,GAEA,MAAMD,EAAqC,CAAE,EAE7C,IAAK,IAAIE,EAAI,EAAGA,EAAIH,EAAOI,OAAQD,IAAK,CAAA,IAAAE,EACtC,MAAMC,EAAQN,EAAOG,GACfI,EAAOF,OAAHA,EAAGC,EAAMC,WAANF,EAAAA,EAAYG,KAAK,KAE9B,GAAID,IACGN,EAAOM,KACVN,EAAOM,GAAQ,CAAEE,QAASH,EAAMG,QAASC,KAAM,KAG7CR,GAA0B,CAC5B,MAAMS,EAAQV,EAAOM,GAAMI,OAAS,CAAA,EAEpCV,EAAOM,GAAMI,MAAKC,EAAA,CAAA,EACbD,EAAK,CACR,CAACE,OAAOC,KAAKH,GAAOP,QAASE,EAAMG,SAEvC,CAEJ,CAEA,OAAOR,CACT,CAsCqBc,CACblB,EAAOG,QACNJ,EAAQoB,2BAAsD,QAAzBpB,EAAQqB,cAGhD,MAAO,CACLvB,OAAQ,CAAA,EACRO,OAAQiB,EAAajB,EAAQL,GAEjC,CAIA,OAFAA,EAAQoB,2BAA6BG,EAAuB,CAAE,EAAEvB,GAEzD,CACLF,OAAQD,EAAgB2B,IAAMP,OAAOQ,OAAO,CAAE,EAAE3B,GAAUG,EAAOyB,MACjErB,OAAQ,CAAA,GAGd"}