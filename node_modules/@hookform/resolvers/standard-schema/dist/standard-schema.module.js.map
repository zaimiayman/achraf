{"version":3,"file":"standard-schema.module.js","sources":["../src/standard-schema.ts"],"sourcesContent":["import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport { StandardSchemaV1 } from '@standard-schema/spec';\nimport { FieldError, FieldValues, Resolver } from 'react-hook-form';\n\nfunction parseIssues(\n  issues: readonly StandardSchemaV1.Issue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n\n  for (let i = 0; i < issues.length; i++) {\n    const error = issues[i];\n    const path = error.path?.join('.');\n\n    if (path) {\n      if (!errors[path]) {\n        errors[path] = { message: error.message, type: '' };\n      }\n\n      if (validateAllFieldCriteria) {\n        const types = errors[path].types || {};\n\n        errors[path].types = {\n          ...types,\n          [Object.keys(types).length]: error.message,\n        };\n      }\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Creates a resolver for react-hook-form that validates data using a Standard Schema.\n *\n * @param {Schema} schema - The Standard Schema to validate against\n * @param {Object} resolverOptions - Options for the resolver\n * @param {boolean} [resolverOptions.raw=false] - Whether to return raw input values instead of parsed values\n * @returns {Resolver} A resolver function compatible with react-hook-form\n *\n * @example\n * ```ts\n * const schema = z.object({\n *   name: z.string().min(2),\n *   age: z.number().min(18)\n * });\n *\n * useForm({\n *   resolver: standardSchemaResolver(schema)\n * });\n * ```\n */\nexport function standardSchemaResolver<\n  TFieldValues extends FieldValues,\n  Schema extends StandardSchemaV1<TFieldValues, any>,\n>(\n  schema: Schema,\n  resolverOptions: {\n    raw?: boolean;\n  } = {},\n): Resolver<NonNullable<(typeof schema)['~standard']['types']>['output']> {\n  return async (values: TFieldValues, _, options) => {\n    let result = schema['~standard'].validate(values);\n    if (result instanceof Promise) {\n      result = await result;\n    }\n\n    if (result.issues) {\n      const errors = parseIssues(\n        result.issues,\n        !options.shouldUseNativeValidation && options.criteriaMode === 'all',\n      );\n\n      return {\n        values: {},\n        errors: toNestErrors(errors, options),\n      };\n    }\n\n    options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n    return {\n      values: resolverOptions.raw ? Object.assign({}, values) : result.value,\n      errors: {},\n    };\n  };\n}\n"],"names":["standardSchemaResolver","schema","resolverOptions","values","_","options","_temp2","result","issues","errors","validateAllFieldCriteria","i","length","_error$path","error","path","join","message","type","_extends2","types","_extends","Object","keys","parseIssues","shouldUseNativeValidation","criteriaMode","toNestErrors","validateFieldsNatively","raw","assign","value","validate","_temp","Promise","resolve","then","_result","e","reject"],"mappings":"gTAqDgBA,EAIdC,EACAC,GAIA,YAJAA,IAAAA,IAAAA,EAEI,CAAE,GAEN,SAAcC,EAAsBC,EAAGC,GAAW,IAAA,IAAAC,EAAAA,WAMhD,GAAIC,EAAOC,OAAQ,CACjB,IAAMC,EAjEZ,SACED,EACAE,GAIA,IAFA,IAAMD,EAAqC,CAAA,EAElCE,EAAI,EAAGA,EAAIH,EAAOI,OAAQD,IAAK,CAAAE,IAAAA,EAChCC,EAAQN,EAAOG,GACfI,EAAOF,OAAHA,EAAGC,EAAMC,WAANF,EAAAA,EAAYG,KAAK,KAE9B,GAAID,IACGN,EAAOM,KACVN,EAAOM,GAAQ,CAAEE,QAASH,EAAMG,QAASC,KAAM,KAG7CR,GAA0B,CAAA,IAAAS,EACtBC,EAAQX,EAAOM,GAAMK,OAAS,CAAA,EAEpCX,EAAOM,GAAMK,MAAKC,EACbD,CAAAA,EAAAA,IAAKD,EAAA,IACPG,OAAOC,KAAKH,GAAOR,QAASE,EAAMG,QAAOE,GAE9C,CAEJ,CAEA,OAAOV,CACT,CAsCqBe,CACbjB,EAAOC,QACNH,EAAQoB,2BAAsD,QAAzBpB,EAAQqB,cAGhD,MAAO,CACLvB,OAAQ,CAAA,EACRM,OAAQkB,EAAalB,EAAQJ,GAEjC,CAIA,OAFAA,EAAQoB,2BAA6BG,EAAuB,CAAE,EAAEvB,GAEzD,CACLF,OAAQD,EAAgB2B,IAAMP,OAAOQ,OAAO,CAAE,EAAE3B,GAAUI,EAAOwB,MACjEtB,OAAQ,GACR,EAtBEF,EAASN,EAAO,aAAa+B,SAAS7B,GAAQ8B,gBAC9C1B,aAAkB2B,QAAO,OAAAA,QAAAC,QACZ5B,GAAM6B,KAAA,SAAAC,GAArB9B,EAAM8B,CAAgB,EAAAH,IAAAA,OAAAA,QAAAC,QAAAF,GAAAA,EAAAG,KAAAH,EAAAG,KAAA9B,GAAAA,IAqB1B,CAAC,MAAAgC,GAAAJ,OAAAA,QAAAK,OAAAD,EACH,CAAA,CAAA"}